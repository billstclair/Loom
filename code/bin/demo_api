#!/usr/bin/perl -w
use strict;

# Here's a demo of the Loom API in a single source code file.  (Well, we do
# rely on LWP::UserAgent to handle the details of the HTTP connection.)
#
# Quick background:
#   The Grid is a two-dimensional array of integers.
#   The Archive is a one-dimensional array of strings.
#
# These functions are ordered from bottom-up, as in C, with the final "main"
# function appearing at the end of the file.

use LWP::UserAgent;
# NOTE: You must install Crypt::SSLeay in order for https to work.

# Unquote a single char using C quoting rules.
sub code_to_char
	{
	my $code = shift;

	return "\n" if $code eq "n";
	return $code if $code eq "\"";
	return "\t" if $code eq "t";
	return $code if $code eq "\\";
	return chr(oct($code));
	}

# Unquote a string using C quoting rules.
sub unquote
	{
	my $str = shift;

	$str =~ s/\\(\d{3}|\\|n|t|\")/code_to_char($1)/egs;

	return $str;
	}

# Take the text returned from a Loom API call and return a hash of the keys and
# values.
sub parse_kv
	{
	my $text = shift;

	my $hash = {};
	my $key = "";

	for my $line (split(/\n/,$text))
		{
		my $type = substr($line,0,1);
		$line = unquote(substr($line,1));

		$key = $line if $type eq ":";
		$hash->{$key} = $line if $type eq "=";
		}

	return $hash;
	}

my $user_agent;

sub init_user_agent
	{
	# Set the number of connections to cache for "Keep Alive".
	$user_agent = LWP::UserAgent->new(keep_alive => 20);

	# Set the number of seconds to wait before aborting connection.
	$user_agent->timeout(180);
	}

# Get the the $url and return the response from the server as text.  Die if it
# doesn't succeed.
sub get_url
	{
	my $url = shift;

	init_user_agent() if !defined $user_agent;

	my $response = $user_agent->get($url);

	return $response->decoded_content if $response->is_success;

	die $response->status_line;
	}

# Print a hash table for trace purposes.
sub print_hash
	{
	my $hash = shift;

	for my $key (sort keys %$hash)
		{
		my $val = $hash->{$key};
		print qq{key "$key" val "$val"\n};
		}
	print "\n";
	}

# Get the Loom API URL and return the result as a hash.  This also prints the
# raw text returned from the server and the corresponding hash.
sub loom_api
	{
	my $url = shift;

	my $text = get_url($url);
	my $hash = parse_kv($text);
	print $text;
	print_hash($hash);

	return $hash;
	}

#############

my $server_name = "https://loom.cc";

# This asset type is usage tokens.
my $asset_type = "00000000000000000000000000000000";

# Two arbitrary locations.
my $loc_A = "2cb0ac792060cfb88a3f186013b41df3";
my $loc_B = "bbb4b657a6e36e2cd607cf5d001cb018";

# Here we demonstrate taking a look at the balance in Grid location A.
sub demo_grid_touch
	{
	loom_api(
	"$server_name/?function=grid&action=touch&type=$asset_type&loc=$loc_A");
	}

# Here we demonstrate moving $qty units from location A to location B.  Note
# that *all* asset types in Loom are counted in whole integers only, so pay
# attention to the scale factor for the asset type you're using.  For example,
# a dollar-based asset type is probably based in pennies, so to move $142.57
# you would actually use the quantity 14257 which is the number of whole
# pennies to move.

sub demo_grid_move
	{
	my $qty = 10;
		# The number of units to move.  If you use a negative number, it simply
		# moves the units in the opposite direction.

	my $hash =
	loom_api(
	"$server_name/?function=grid&action=move&type=$asset_type"
		."&qty=$qty"
		."&orig=$loc_A"
		."&dest=$loc_B"
		);

	if ($hash->{status} eq "success")
		{
		print "I succeeded in moving $hash->{qty} units\n";
		}
	else
		{
		print "I failed to move $hash->{qty} units\n";
		}
	}

# Here we demonstrate looking directly into an Archive location.
sub demo_archive_touch
	{
	loom_api(
	"$server_name/?function=archive&action=touch"
		."&loc=$loc_A");
	}

# Do the demo.
sub main
	{
	demo_grid_touch();
	demo_grid_move();
	demo_archive_touch();
	}

main();
