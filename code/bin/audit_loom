#!/usr/bin/perl -w
use strict;

use FindBin;
my $TOP;
BEGIN { $TOP = "$FindBin::RealBin/../.." }
use lib "$TOP/code";

use Getopt::Long;
use Loom::DB::GNU;
use Loom::Int128;

main->new->run;

sub new
	{
	my $class = shift;

	my $s = bless({},$class);
	return $s;
	}

sub run
	{
	my $s = shift;

	$s->get_options;
	$s->audit_grid;

	exit(0);
	}

sub get_options
	{
	my $s = shift;

	my $opt = {};
	my $ok = GetOptions($opt,"l","s","h");

	if (!$ok || $opt->{h})
		{
		my $prog_name = $0;
		$prog_name =~ s#.*/##;

	print STDERR <<EOM;
Usage: $prog_name [-l | -s]

Audit the Loom grid.
  $prog_name      # Check, but don't show detail.
  $prog_name -l   # List grid values.
  $prog_name -s   # Show subtotals.
EOM
		exit(2);
		}

	$s->{verbose} = $opt->{l} || $opt->{s};
	$s->{show_subtotal} = $opt->{s};

	return;
	}

sub audit_grid
	{
	my $s = shift;

	my $dbname = "$TOP/data/app/loom.db";

	$s->{db} = Loom::DB::GNU->new($dbname);
	$s->{type_table} = {};

	my $key = $s->{db}->first_key;

	while (defined $key)
		{
		if ($key =~ /^grid_V/)
			{
			die if length($key) != 54;

			my $data = substr($key,6);

			my $type = unpack("H*",substr($data,0,16));
			my $hash = unpack("H*",substr($data,16,16));

			my $val = $s->{db}->get($key);

			my $o_type = $s->{type_table}->{$type};
			if (!defined $o_type)
				{
				$o_type = {};
				$o_type->{total} = Loom::Int128->from_dec("0");
				$o_type->{list} = [];

				$s->{type_table}->{$type} = $o_type;
				}

			$o_type->{total}->add(Loom::Int128->from_dec($val));

			push @{$o_type->{list}}, [$hash,$val];
			}

		$key = $s->{db}->next_key($key);
		}

	# Now sort the item lists by hash.
	for my $type (keys %{$s->{type_table}})
		{
		my $o_type = $s->{type_table}->{$type};
		$o_type->{list} = [ sort { $a->[0] cmp $b->[0] } @{$o_type->{list}} ];
		}

	print "-- balances by type\n" if $s->{verbose};

	my @types = sort keys %{$s->{type_table}};
	my @bad_types;

	for my $type (@types)
		{
		my $o_type = $s->{type_table}->{$type};
		my $total = $o_type->{total};
		print "\n" if $s->{verbose};
		my $q_total = $total->to_dec;

		my $b_type = pack("H*",$type);
		my $b_issuer = $s->{db}->get("grid_I$b_type");
		my $issuer = unpack("H*",$b_issuer);
		my $dsp_issuer = substr($issuer,0,8);

		if ($s->{verbose})
			{
			print "type $type issuer $dsp_issuer\n";

			if ($s->{show_subtotal})
				{
				printf "  %-8s %20s %20s\n", "TOTAL", "", $q_total;
				printf "  %-8s %20s %20s\n", "HASH", "VAL", "SUBTOTAL";
				}
			else
				{
				printf "  %-8s %20s\n", "HASH", "VAL";
				}
			}

		my $subtotal = Loom::Int128->from_dec("0");

		for my $item (@{$o_type->{list}})
			{
			my ($hash,$val) = @$item;
			my $dsp_hash = substr($hash,0,8);
			$subtotal->add(Loom::Int128->from_dec($val));

			my $q_subtotal = $subtotal->to_dec;

			if ($s->{verbose})
				{
				if ($s->{show_subtotal})
					{
					printf "  %-8s %20s %20s\n", $dsp_hash, $val, $q_subtotal;
					}
				else
					{
					printf "  %-8s %20s\n", $dsp_hash, $val;
					}
				}
			}

		die if $subtotal->to_dec ne $q_total;

		if ($q_total eq "-1")
			{
			# The type totals to -1 as expected.  Let's make sure the issuer
			# location has been bought.

			if ($b_issuer eq "")
				{
				# ERROR: Issuer location has not been bought.
				push @bad_types, $type;
				}
			}
		elsif ($q_total eq "0")
			{
			# The type totals to 0.  In this case we expect that nobody has
			# yet bought the issuer location (which is why the -1 didn't
			# appear during the key scan).

			if ($b_issuer ne "")
				{
				# ERROR: Issuer location has been bought, but we total to 0.
				push @bad_types, $type;
				}
			}
		else
			{
			push @bad_types, $type;
			}
		}

	print "\n" if $s->{verbose};

	if (@bad_types)
		{
		print "--- FAIL: Something is wrong with the following types:\n";
		for my $type (@bad_types)
			{
			print "  $type\n";
			}
		exit(3);
		}

	my $num_types = @types;
	print "--- SUCCESS:  All $num_types types look good.\n";
	return;
	}
